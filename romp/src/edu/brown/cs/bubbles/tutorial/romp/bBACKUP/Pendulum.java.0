
package edu.brown.cs.bubbles.tutorial.romp;

import java.util.List;


/** A class representing the pendulum.	This is where most of the real work gets done.
@author 176
*/
public class Pendulum {
/** The angle of the pendulum */
private Angle	   angle;
/** The mass of the pendulum */
private static float    mass	  = 1;
/** The length of the pendulum wire */
private static float    length	= 7;
/** The height of the bottom of the pendulum above the x,y plane when the pendulum
is at rest */
private static float    restingHeight = .75f;
/** The position of the support pole */
private static Position pole	  = new Position(2.25f,2.25f,0);
/** The velocity of the pendulum */
private Velocity	vel;
/** The magnet attached to the end of the pendulum */
private Magnet	  mag;

// Constructors
/** Construct a pendulum with initial position x,y.
The z-coordinate and angle are calculated automatically.
The initial velocity is set to 0 */
public Pendulum(float x,float y)
{
   double height;
   if ((x == 0.0) && (y == 0.0)) {
      angle = new Angle(0);
      height = restingHeight;
   }
   else {
      double sine = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / length;
      angle = new Angle(Math.asin(sine));
      System.err.println("Pendulum initially at angle: " + angle);
      height = restingHeight + (length * angle.cosine());
   }
   Position pos = new Position(x,y,(float) height);
   // System.err.println("Set position " + x + ", " + y + ", " + height);
   vel = new Velocity(0,0,0);
   // System.err.println("Set velocity");
   mag = new Magnet(pos,new Direction(-1));
   // System.err.println("Done creating pendulum");
}

// Accessors
public Position getPosition()
{
   return mag.getPos();
}

public Velocity getVelocity()
{
   return vel;
}

public Angle getAngle()
{
   return angle;
}

public static float getMass()
{
   return mass;
}

public static float getLength()
{
   return length;
}

/** Returns the 3D distance of the pendulum from 0,0,0 */
public float getDistance()
{
   // return distance from 0,0,0
   Position pos = mag.getPos();
   return (float) Math.sqrt(Math.pow(pos.getX(), 2) + Math.pow(pos.getY(), 2)
	    + Math.pow(pos.getZ(), 2));
}

public Magnet getMagnet()
{
   return mag;
}

public static float getRestingHeight()
{
   return restingHeight;
}

// Modifiers
/** Move the pendulum to a new position.  Recalculate the z-coordinate and angle
*/
public void setPosition(Position newPos)
{
   float x = newPos.getX();
   float y = newPos.getY();
   double height;

   if ((x == 0.0) && (y == 0.0)) {
      angle = new Angle(0);
      height = restingHeight;
   }
   else {
      double sine = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / length;
      angle = new Angle(Math.asin(sine));
      height = restingHeight + (length * angle.cosine());
   }
   Position pos = new Position(x,y,(float) height);
   mag.move(pos);
   // System.err.println("Pendulum at angle: " + angle);
}

// Utilities
/** Detect a collision between the pendulum and something located at position pos */
public boolean collision(Position pos)
{
   double dist = Math.sqrt(Math.pow(pos.getX() - pole.getX(), 2)
	    + Math.pow(pos.getY() - pole.getY(), 2));
   if (dist < .5) {
      System.err.println("Bonk");
      return true;
   }
   else {
      return false;
   }
}

/** Update the position of the pendulum given a set of magnets
Calculate and sum the forces of gravity, friction and the forces
generated by each of the magnets in the set.	From this, calculate the acceleration.
Call updateVariable with the acceleration, a distance step, and a timestep.
@return The time change covered by this update.
*/
public float update(List<Magnet> magnets)
{
   // Sum up the forces
   Force sumForce = Gravity.calculateForce(this);
   sumForce = sumForce.add(Friction.calculateForce(this));
   for (Magnet m : magnets) {
      sumForce = sumForce.add(getMagnet().calculateForce(m));
   }

   // Calculate the acceleration
   PhysicsVector acceleration = sumForce.scalarMultiply(1 / getMass());
   // System.err.println("Total acceleration is " + acceleration);

   // return updateFixed(acceleration, .0001f);
   return updateVariable(acceleration, .01f, .01f);
}

/** Update the pendulum's position and velocity using a fixed timestep.
Change in position is velocity * timestep.
Change in velocity is acceleration * timestep.
Detect and handle collisions.
@return The time change covered by this update (i.e. the timestep)
*/
private float updateFixed(PhysicsVector acceleration,float timestep)
{
   // this does the update based on a fixed timestep

   // update position
   // move based on current velocity and some timestep
   Position pos = vel.updatePosition(mag.getPos(), timestep);
   if ((pos.getX() > length) || (pos.getY() > length)) {
      System.err.println("Got a length too long");
   }
   setPosition(pos);
   // System.err.println("Updated pendulum position to " + pos);


   // update velocity
   // update based on acceleration and timestep
   vel = vel.updateVelocity(acceleration, timestep);
   // need to detect collision here - elastic
   if (collision(pos)) {
      vel = new Velocity(vel.reverse());
   }
   // System.err.println("Updated pendulum velocity to " + vel);

   // System.err.println(this);
   return timestep;
}

/** Update the pendulum's position and velocity using a variable timestep.
Calculate the timestep as the minimum of the time required to either (a) move the pendulum
a distance of distStep or (b) change the velocity by vStep.  Once the timestep has been calculated,
call updateFixed with the timestep.
  @return The time change covered by this update (i.e. the timestep)
  */
private float updateVariable(PhysicsVector acceleration,float distStep,float vStep)
{
   // calculate timestep based on current velocity
   // also need to adjust if a change in direction is upcoming.
   float timestep;
   timestep = Math.min(Math.abs(distStep / (float) vel.getR()),
	    Math.abs(vStep / (float) acceleration.getR()));
   if (Float.isNaN(timestep)) {
      timestep = .001f;
   }
   // System.err.println(timestep);
   return updateFixed(acceleration, timestep);
}

public String toString()
{
   return getMagnet().toString();
}


}
